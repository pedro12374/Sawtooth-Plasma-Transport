import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq

def find_dominant_frequency(data_file):
    """
    Loads a time series, performs an FFT, plots the spectrum,
    and identifies the dominant frequency.
    
    Args:
        data_file (str): Path to the continuous data file.
    
    Returns:
        float: The dominant frequency, or None if not found.
    """
    try:
        # Load the time series data generated by the C++ code
        # We skip the header row with comments='#'
        t, x, y = np.loadtxt(data_file, unpack=True, comments='#', delimiter='\t')
    except Exception as e:
        print(f"Error loading data file '{data_file}': {e}")
        return None

    # --- Perform the Fast Fourier Transform (FFT) ---
    N = len(x)  # Number of data points
    
    # Check if there's enough data and constant time step
    if N < 2:
        print("Not enough data points for FFT.")
        return None
        
    dt = t[1] - t[0] # Calculate the time step from the data

    # Compute the FFT of the x-component
    yf = fft(x)
    # Compute the frequency bins
    xf = fftfreq(N, dt)

    # We only care about the positive frequencies
    positive_mask = xf > 0
    xf_pos = xf[positive_mask]
    yf_pos = np.abs(yf[positive_mask])

    # --- Find the Peak Frequency ---
    try:
        # Find the index of the maximum amplitude in the positive spectrum
        dominant_idx = np.argmax(yf_pos)
        dominant_frequency = xf_pos[dominant_idx]
        
        # The corresponding period is the inverse of the frequency
        new_sampling_period_T = 1 / dominant_frequency
    except IndexError:
        print("Could not find a dominant frequency.")
        return None

    # --- Plotting the results ---
    """"
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # Plot the original time series (a small part of it)
    ax1.plot(t[:10000], x[:10000]) # Plot first 1000 points to see the oscillation
    ax1.set_title("Time Series (Sample)")
    ax1.set_xlabel("Time (t)")
    ax1.set_ylabel("Position (x)")
    ax1.grid(True)

    # Plot the frequency spectrum
    ax2.plot(xf_pos, yf_pos)
    ax2.set_title("Frequency Spectrum (FFT)")
    ax2.set_xlabel("Frequency (f)")
    ax2.set_ylabel("Amplitude")
    ax2.axvline(dominant_frequency, color='r', linestyle='--', label=f'Peak at f={dominant_frequency:.4f}')
    ax2.legend()
    ax2.grid(True)
    
    ax2.set_xlim(0, 2) # Optional: Zoom into a frequency range if needed

    plt.tight_layout()
    #plt.show()
"""
    print(f"Analysis of '{data_file}':")
    #print(f"Dominant Frequency (f) found at: {dominant_frequency:.6f}")
    #print(f"This corresponds to a new sampling period (T = 1/f) of: {new_sampling_period_T:.6f}")
    
    return new_sampling_period_T

# --- EXECUTE THE ANALYSIS ---
# Replace this with the actual filename generated by your C++ code




print(np.round(np.pi,4))
print(np.round(np.pi/4,4))
print(np.round(np.pi/2,4))
print(np.round(3*np.pi/4,4))
Vtau = [0.0,round(np.pi/4,4),round(np.pi/2,4),round(3*np.pi/4,4), round(np.pi,4)]
Vbeta = [0.0,np.round(np.pi/2,4)]
VA2 = [0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
for i in range(0, 5):
    tau = Vtau[i]
    for j in range(0, 2):       
        beta = Vbeta[j]
        for k in range(0,11):
            A2 = VA2[k]
            filename_to_analyze = f"../Particle/A2_{A2:.4f}_{tau:.4f}_{beta:.4f}.csv"
            new_T = find_dominant_frequency(filename_to_analyze)
            if new_T:
                #print(f"\n T = {new_T:.6f} and {(new_T)/(2*np.pi):.6f} ")
                if np.mod(new_T/ (2 * np.pi),1) >  0.2:
                    print(f"AAA {new_T/ (2 * np.pi)} ")